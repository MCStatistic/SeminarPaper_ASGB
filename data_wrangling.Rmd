---
title: "Data Wrangling"
author: "Marlon Schumacher"
date: "27 11 2018"
output: html_document
---

## Data Wrangling with PDF Documents

[tidyless introduction to it](https://www.r-bloggers.com/how-to-extract-data-from-a-pdf-file-with-r/)

Used package: [pdftools](https://cran.r-project.org/web/packages/pdftools/pdftools.pdf)

[very great tutorial](https://www.brodrigues.co/blog/2018-06-10-scraping_pdfs/)


```{r}
# loading nedded packages
p_load(dplyr, ggplot2, pdftools, stringr, lubridate)

# setting options for text mining
options(stringsAsFactors = FALSE)

file_1 <- pdf_text("./18_btd/1800038.pdf") %>% 
  readr::read_lines() %>% 
  unlist()

 text_string <- strsplit(file_1, "\n")
  text_string_first<-text_string[[1]]
  typ<-text_string_first[3]
  typen<- c(typen, typ)
  
  typ<- text_string[[1]][3]
  
  text_string <- pdf_text("./18_btd/1800038.pdf") %>% 
    strsplit("\n") 
   typ<- text_string[[1]][3]
  text_string_first<-text_string[[1]][3:4]

file_test <- map()

full_file <- path_18[1:10] %>% 
  map(~pdf_text(.x))

readr::read_lines(full_file[[1]])
full_file[1] %>% 
  unlist() %>% 
  str_split("\n") %>% 
  unlist()

pdf_text(path_18[1])

corpus <- Corpus(VectorSource(full_file))
readr::read_lines(corpus$content[1])

class(file_2)


file_2 <- pdf_text("./18_btd/1800038.pdf") %>% 
  unlist()

file_corpus <- Corpus(VectorSource(file))
file_corpus$content

# removing stop words
head(stopwords("de"))
tm_map(corpus, removeWords, stopwords("de"))

file <- str_split(file, "\n")

# cat() makes it more readable
cat(file[1])

testing <- pdf_text("./18_btd/1800038.pdf") %>% 
  strsplit("\n") %>% 
  unlist()

pdf_text_2 <- function(pdf){
  testing <- pdf_text(pdf) %>% 
    strsplit("\n") %>% 
    unlist()
}

pdf_vector_test <- c("./18_btd/1800038.pdf", "./18_btd/1800039.pdf", "./18_btd/1800040.pdf")
map_test <- map(pdf_vector_test,
                ~pdf_text_2(.x))

```


## Forloop
```{r}
test_path <- path_18[1:100]
test_path %<>% 
  str_replace_all("./18_btd", "./test")
typen<-c()

for (i in seq_along(test_path)) {
  text_string <- pdf_text(test_path[i]) %>% 
    strsplit("\n") 
  
  typ <- text_string[[1]][3]
  typen <- c(typen, typ)
  
  a <-grep("Kleine Anfrage", typ)
  if(length(a) >= 1) {
  } else {
    unlink(test_path[i], recursive = FALSE, force = FALSE)
  }
}
print("Vorgang abgeschlossen!")


typen <- c()
test_path_clean <- c()

for (i in seq_along(test_path)) {
  # reading the pdf document
  text_string <- pdf_text(test_path[i]) %>% 
    strsplit("\n") 
  # select the row of the document-type
  typ <- text_string[[1]][3]
  typen <- c(typen, typ)
  
  # creating pattern which should match!
  patterns <- c("Kleine Anfrage", "Große Anfrage")
  
  # grep only the characters which are defined in the patterns string
  a <- grep(paste(patterns, collapse="|"), typ)
  
  # if there is a matching in between the patterns & document type, the string will be longer than 1
  if(length(a) >= 1) {
    test_path_clean <- c(test_path_clean, test_path[i])
    # if there is no matching, delete the file
  } else {
    unlink(test_path[i])
  }
}
print("Vorgang abgeschlossen!")

test_path_clean
head(typen)

```


## Deleting Files
```{r}
# creating 
typen_anfragen_18 <- c()
typen_anfragen_18_clean <- c()
path_anfragen_18_clean <- c()

path_anfragen_18 <- path_18 %>% 
  str_replace_all("./18_btd", "./18_btd_anfragen")

# Deleting all documents which are != to type "Kleine Anfrage" or "Große Anfrage"
for (i in seq_along(path_anfragen_18)) {
  # reading the pdf document
  text_string <- pdf_text(path_anfragen_18[i]) %>% 
    strsplit("\n") 
  # select the row of the document-type
  typ <- text_string[[1]][3]
  typen_anfragen_18 <- c(typen_anfragen_18, typ)
  
  # creating pattern which should match!
  patterns <- c("Kleine Anfrage", "Große Anfrage")
  
  # grep only the characters which are defined in the patterns string
  a <- grep(paste(patterns, collapse="|"), typ)
  
  # if there is a matching in between the patterns & document type, the string will be longer than 1
  if(length(a) >= 1) {
    
    # if there is a matching, save the path of the document in the vector path_18_clean
    path_anfragen_18_clean <- c(path_anfragen_18_clean, path_anfragen_18[i])
    typen_anfragen_18_clean <- c(typen_anfragen_18_clean, typ)
    
    # if there is no matching, delete the file
  } else {
    unlink(path_anfragen_18[i])
  }
}
print("Vorgang abgeschlossen!")

# inspecting vectors -> no trouble
head(typen_anfragen_18_clean, 10)
head(path_anfragen_18_clean, 10)

# saving vectors
save(typen_anfragen_18_clean, file = "type_a_18_clean.RData")
save(path_anfragen_18_clean, file = "path_a_18_clean.RData")
```


```{r}
# loading vectors
load("type_a_18_clean.RData")
load("path_a_18_clean.RData")

# removing parts which aren't needed anymore
path_anfragen_18_clean %<>% 
  str_remove_all("./18_btd_anfragen/") %>% 
  str_remove_all(".pdf")

# creating df
df_18 <- as.data.frame(cbind(as.character(path_anfragen_18_clean), 
                    typen_anfragen_18_clean), 
              stringsAsFactors = FALSE)

# renaming columns & saving the df
df_18 %<>% 
  rename(file = V1) %>% 
  rename(type = typen_anfragen_18_clean)

save(df_18, file = "df_18.RData")

# inspecting df_18
df_18 %>% 
  group_by(type) %>% 
  summarise(n = n()) %>% 
  mutate(perc = n/nrow(df_18)*100)
```

## Getting the Date of Document
```{r}
load("path_a_18_clean.RData")

# # checking vector
# path_anfragen_18_clean
# length(path_anfragen_18_clean)
# # testing loop for single case
# text_string <- pdf_text(path_anfragen_18_clean[1]) %>% 
#     strsplit("\n") %>% 
#     unlist()
#   # select the row of the document-type
#   datum_string <- strsplit(text_string, split='\r', fixed=TRUE)[2] 
#   datum_string <- gsub(" ", "", datum_string, fixed = TRUE)
#   final_datum <- unlist(strsplit(datum_string, split='ode', fixed=TRUE))[2]
#   date <- c(date, final_datum)

# creating string for the date
date <- c()

for (i in seq_along(path_anfragen_18_clean)) {
  # reading the pdf document
  text_string <- pdf_text(path_anfragen_18_clean[i]) %>% 
    strsplit("\n") %>% 
    unlist()
  # select the row of the document-type
  datum_string <- strsplit(text_string, split='\r', fixed=TRUE)[2] 
  datum_string <- gsub(" ", "", datum_string, fixed = TRUE)
  final_datum <- unlist(strsplit(datum_string, split='ode', fixed=TRUE))[2]
  date <- c(date, final_datum)
}

# checking string
date
length(date) # looks fine :)

# add the date string to the data frame
df_18$date <- date

# saving df
save(df_18, file = "df_18.RData")
```

## Getting the party for each document
```{r}
# testing the function which will part of the loop
party <- c()
text_string <- pdf_text(path_anfragen_18_clean[413]) %>% 
     strsplit("\n") %>% 
     unlist()
  partei<-text_string[4:19]
  a <- str_detect(partei, "GRÜNEN")
  
  if(TRUE %in% a){
    z <- "Grüne"
  } else{
      a <- str_detect(partei, "LINKE")
      
      if(TRUE %in% a){
        z <- "Linke"
      } else{
          z <- "NA"
        }
    }
  party <- c(party, z)

# test looks fine...let the looping start  
party <- c()
for(i in seq_along(path_anfragen_18_clean)){
  text_string <- pdf_text(path_anfragen_18_clean[i]) %>% 
     strsplit("\n") %>% 
     unlist()
  partei<-text_string[4:20]
  a <- str_detect(partei, "GRÜNEN")
  
  if(TRUE %in% a){
    z <- "Grüne"
  } else{
      b <- str_detect(partei, "LINKE")
      
      if(TRUE %in% b){
        z <- "Linke"
      } else{
        c <- str_detect(partei, "SPD")
        
        if(TRUE %in% c){
          z <- "SPD"
        } else{
          d <- str_detect(partei, "CDU/CSU")
          
          if(TRUE %in% d){
            z <- "Union"
          } else{
          z <- "NA"
          }
        }
      }
    }
  party <- c(party, z)
}

# checking vector
party
length(party)

# adding vector to the df
df_18$party <- party

# changing the one character value which is kind of akward...
df_18 %<>% 
  mutate(type = case_when(type == " Kleine Anfrage" ~ "Kleine Anfrage",
                          TRUE ~ type))

# just a short inspection
df_18 %>% 
  group_by(party, type) %>% 
  summarise(n = n()) %>% 
  filter(party != "NA")

# saving data frame
save(df_18, file = "df_18.RData")
```

## Plotting n() for each party (+ by year)
```{r}
# plotting n(type) for each party
df_18 %>% 
  filter(party != "NA" & type != "Große Anfrage") %>% 
  group_by(party) %>% 
  summarise(n = n()) %>% 
  ggplot(aes(party, n)) +
  xlab("") + ylab("") +
  geom_col(stat = "identity", 
           fill = "skyblue4") +
  geom_text(aes(label = n), 
            size = 3, 
            vjust = -0.5) +
  theme_bw()

# green color = darkseagreen

# testint date transformation with base code
# as.Date(df_18$date, "%d.%m.%Y")

# year on x and party als filler
df_18 %>% 
  filter(party != "NA" & type != "Große Anfrage") %>% 
  mutate(date_n = as.Date(date, "%d.%m.%Y")) %>% 
  mutate(year = year(date_n)) %>% 
  group_by(party, year) %>% 
  summarise(n = n()) %>% 
  mutate(year = as.character(year)) %>% 
  mutate(year = case_when(year == "2013" ~ "2013\nOkt-Dez",
                          year == "2017" ~ "2017\nJan-Okt",
                          TRUE ~ year)) %>% 
  ggplot(aes(x = as.factor(year), fill = party, y = n)) +
  geom_bar(position="dodge", 
           stat="identity") +
  geom_text(position = position_dodge(width = 1),
            aes(label = n),
            vjust = -0.5,
            size = 3) +
  xlab("") + 
  ylab("") + 
  labs(fill = "Partei") +
  scale_fill_brewer(palette = "Set2") +
  theme_bw()
```

## Stack Overflow Stuff - Got no Hobbies...I know
```{r}
pupil_ratio <- read.csv('pupil_ratio.csv')  #this data has all the countries I want
countries <-as.vector(pupil_ratio$Country.Name) #I convert it to a vector

d_f <- read.csv('fertility_rate.csv') %>%
  gather(year, fert, X1960:X2017) %>% 
  dplyr::filter(Country.Name %in% countries) # only select all countries which are in countries

# testing
df_18 %>% 
  filter(party != "NA" & type != "Große Anfrage") %>% 
  mutate(date_n = as.Date(date, "%d.%m.%Y")) %>% 
  mutate(year = year(date_n)) %>% 
  group_by(party, year) %>% 
  summarise(n = n()) %>% 
  filter(party %in% c("Grüne", "Linke"))
```


suport vector model Machine Learning

## corpus dtype

This procedure is not used for data manipulation! However, the code exists for documentation.
```{r}

# using tm package for reading pdf-documents
read <- readPDF(engine = "xpdf", 
                control = list(text = "-layout"))

document <- Corpus(URISource("./18_btd/1800038.pdf"), 
                   readerControl = list(reader = read))

# creating test_vector for pdf reading
pdf_vector_test <- c("./18_btd/1800038.pdf", "./18_btd/1800039.pdf", "./18_btd/1800040.pdf")

document2 <- Corpus(URISource(pdf_vector_test, encoding = "UTF-8"), 
                   readerControl = list(reader = read))

content(document2[[3]])

meta(document2[[3]])

doc_2 <- content(document2[[1]])
head(doc_2, 15)

doc_2 %>% 
  str_replace_all("\xdc", "ü") %>% 
  str_replace_all("\xfc", "ü") %>% 
  str_replace_all("\xf6", "ö") 
```
