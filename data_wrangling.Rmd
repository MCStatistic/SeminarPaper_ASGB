---
title: "Data Wrangling 18. Bundestag"
author: "Marlon Schumacher"
date: "27 11 2018"
output: html_document
---

## Data Wrangling with PDF Documents

[tidyless introduction to it](https://www.r-bloggers.com/how-to-extract-data-from-a-pdf-file-with-r/)

Used package: [pdftools](https://cran.r-project.org/web/packages/pdftools/pdftools.pdf)

[very great tutorial](https://www.brodrigues.co/blog/2018-06-10-scraping_pdfs/)


```{r}
# loading nedded packages
p_load(dplyr, haven, readr, ggplot2, pdftools, stringr, lubridate, RColorBrewer)

```

## Deleting Files
```{r}
# creating 
typen_anfragen_18 <- c()
typen_anfragen_18_clean <- c()
path_anfragen_18_clean <- c()

path_anfragen_18 <- path_18 %>% 
  str_replace_all("./18_btd", "./18_btd_anfragen")

# Deleting all documents which are != to type "Kleine Anfrage" or "Große Anfrage"
for (i in seq_along(path_anfragen_18)) {
  # reading the pdf document
  text_string <- pdf_text(path_anfragen_18[i]) %>% 
    strsplit("\n") 
  # select the row of the document-type
  typ <- text_string[[1]][3]
  typen_anfragen_18 <- c(typen_anfragen_18, typ)
  
  # creating pattern which should match!
  patterns <- c("Kleine Anfrage", "Große Anfrage")
  
  # grep only the characters which are defined in the patterns string
  a <- grep(paste(patterns, collapse="|"), typ)
  
  # if there is a matching in between the patterns & document type, the string will be longer than 1
  if(length(a) >= 1) {
    
    # if there is a matching, save the path of the document in the vector path_18_clean
    path_anfragen_18_clean <- c(path_anfragen_18_clean, path_anfragen_18[i])
    typen_anfragen_18_clean <- c(typen_anfragen_18_clean, typ)
    
    # if there is no matching, delete the file
  } else {
    unlink(path_anfragen_18[i])
  }
}
print("Vorgang abgeschlossen!")

# inspecting vectors -> no trouble
head(typen_anfragen_18_clean, 10)
head(path_anfragen_18_clean, 10)

# saving vectors
save(typen_anfragen_18_clean, file = "type_a_18_clean.RData")
save(path_anfragen_18_clean, file = "path_a_18_clean.RData")
```


```{r}
# loading vectors
load("type_a_18_clean.RData")
load("path_a_18_clean.RData")

# removing parts which aren't needed anymore
path_anfragen_18_clean %<>% 
  str_remove_all("./18_btd_anfragen/") %>% 
  str_remove_all(".pdf")

# creating df
df_18 <- as.data.frame(cbind(as.character(path_anfragen_18_clean), 
                    typen_anfragen_18_clean), 
              stringsAsFactors = FALSE)

# renaming columns & saving the df
df_18 %<>% 
  rename(file = V1) %>% 
  rename(type = typen_anfragen_18_clean)

save(df_18, file = "df_18.RData")

# inspecting df_18
df_18 %>% 
  group_by(type) %>% 
  summarise(n = n()) %>% 
  mutate(perc = n/nrow(df_18)*100)
```

## date for documents
```{r}
load("path_a_18_clean.RData")

# # checking vector
# path_anfragen_18_clean
# length(path_anfragen_18_clean)
# # testing loop for single case
# text_string <- pdf_text(path_anfragen_18_clean[1]) %>% 
#     strsplit("\n") %>% 
#     unlist()
#   # select the row of the document-type
#   datum_string <- strsplit(text_string, split='\r', fixed=TRUE)[2] 
#   datum_string <- gsub(" ", "", datum_string, fixed = TRUE)
#   final_datum <- unlist(strsplit(datum_string, split='ode', fixed=TRUE))[2]
#   date <- c(date, final_datum)

# loading vector ~path_anfragen_18_clean
load("path_a_18_clean.RData")

# creating string for the date
date <- c()

for (i in seq_along(path_anfragen_18_clean)) {
  # reading the pdf document
  text_string <- pdf_text(path_anfragen_18_clean[i]) %>% 
    strsplit("\n") %>% 
    unlist()
  # select the row of the document-type
  datum_string <- strsplit(text_string, split='\r', fixed=TRUE)[2] 
  datum_string <- gsub(" ", "", datum_string, fixed = TRUE)
  final_datum <- unlist(strsplit(datum_string, split='ode', fixed=TRUE))[2]
  date <- c(date, final_datum)
}

# checking string
date
length(date) # looks fine :)

# add the date string to the data frame
df_18$date <- date

# saving df
save(df_18, file = "df_18.RData")
```

## party for documents
```{r}
# loading vector ~path_anfragen_18_clean
load("path_a_18_clean.RData")

# testing the function which will part of the loop
# party <- c()
# text_string <- pdf_text(path_anfragen_18_clean[413]) %>% 
#      strsplit("\n") %>% 
#      unlist()
#   partei<-text_string[4:19]
#   a <- str_detect(partei, "GRÜNEN")
#   
#   if(TRUE %in% a){
#     z <- "Grüne"
#   } else{
#       a <- str_detect(partei, "LINKE")
#       
#       if(TRUE %in% a){
#         z <- "Linke"
#       } else{
#           z <- "NA"
#         }
#     }
#   party <- c(party, z)

# test looks fine...let the looping start  
party <- c()
for(i in seq_along(path_anfragen_18_clean)){
  text_string <- pdf_text(path_anfragen_18_clean[i]) %>% 
     strsplit("\n") %>% 
     unlist()
  partei<-text_string[4:20]
  a <- str_detect(partei, "GRÜNEN")
  
  if(TRUE %in% a){
    z <- "Grüne"
  } else{
      b <- str_detect(partei, "LINKE")
      
      if(TRUE %in% b){
        z <- "Linke"
      } else{
        c <- str_detect(partei, "SPD")
        
        if(TRUE %in% c){
          z <- "SPD"
        } else{
          d <- str_detect(partei, "CDU/CSU")
          
          if(TRUE %in% d){
            z <- "Union"
          } else{
          z <- "NA"
          }
        }
      }
    }
  party <- c(party, z)
}

# checking vector
party
length(party)

# adding vector to the df
df_18$party <- party

# changing the one character value which is kind of akward...
df_18 %<>% 
  mutate(type = case_when(type == " Kleine Anfrage" ~ "Kleine Anfrage",
                          TRUE ~ type))

# just a short inspection
df_18 %>% 
  group_by(party, type) %>% 
  summarise(n = n()) %>% 
  filter(party != "NA")

# saving data frame
save(df_18, file = "df_18.RData")
```

## Plotting n() for each party (+ by year)

[Here](http://sape.inf.usi.ch/quick-reference/ggplot2/colour) are some information for plot colours

Moreover, use the package `RColorBrewer` as an addition:
```{r}
# library(RColorBrewer)
display.brewer.all() 
```


```{r}
# loading data
load("df_18.RData")
library(ggthemes)

# plotting n(type) for each party
df_18 %>% 
  filter(party != "NA" & type != "Große Anfrage") %>% 
  mutate(party = case_when(party == "Union" ~ "CDU/CSU",
                           TRUE ~ party)) %>% 
  group_by(party) %>% 
  summarise(n = n()) %>% 
  ggplot(aes(x = reorder(party, -n), y = n)) +
  xlab("") + ylab("") +
  geom_bar(stat = "identity", 
           fill = "steelblue3") +
  geom_text(aes(label = n), 
            size = 4, 
            vjust = -0.5) +
  theme_economist() 

# theme_economist instead of theme_bw?

# testint date transformation with base code
# as.Date(df_18$date, "%d.%m.%Y")

# year on x and party als filler
df_18 %>% 
  filter(party != "NA" & type != "Große Anfrage") %>% 
  mutate(date_n = as.Date(date, "%d.%m.%Y")) %>% 
  mutate(year = year(date_n),
         party = case_when(party == "Union" ~ "CDU/CSU",
                           TRUE ~ party)) %>% 
  group_by(party, year) %>% 
  summarise(n = n()) %>% 
  mutate(year = as.character(year)) %>% 
  mutate(year = case_when(year == "2013" ~ "2013\nOkt-Dez",
                          year == "2017" ~ "2017\nJan-Okt",
                          TRUE ~ year)) %>% 
  ggplot(aes(x = as.factor(year), fill = reorder(party, -n), y = n)) +
  geom_bar(position="dodge", 
           stat="identity") +
  geom_text(position = position_dodge(width = 1), # positioning for grouped barplot
            aes(label = n), # n-value should be the label for each bar
            vjust = -0.5, # adjusting the vertical dimension (overlapping)
            size = 3) + # setting the size of the label
  xlab("") + 
  ylab("") + 
  labs(fill = "") +
  scale_fill_brewer(palette = "Set2") +
  theme(legend.position="bottom") +
  theme_economist() 

# line plot for quarter
df_18 %>% 
  filter(party != "NA" & type != "Große Anfrage") %>% 
  mutate(date_n = as.Date(date, "%d.%m.%Y")) %>% 
  mutate(quarter = quarter(date_n, with_year = TRUE),
         party = case_when(party == "Union" ~ "CDU/CSU",
                           TRUE ~ party)) %>% 
  filter(party != "CDU/CSU" & party != "SPD") %>% 
  group_by(party, quarter) %>% 
  summarise(n = n()) %>% 
  ggplot(aes(x = quarter, y = n, col = party)) +
  geom_line() +
  xlab("") + ylab("") +
  scale_color_discrete("") +
  theme_economist() +
  ggtitle("Anzahl kleiner Anfragen nach Partei")

```


## Getting Title and content

```{r}

```


suport vector model Machine Learning



## Some Testing
```{r}
# setting options for text mining
options(stringsAsFactors = FALSE)

file_1 <- pdf_text("./18_btd/1800038.pdf") %>% 
  readr::read_lines() %>% 
  unlist()

 text_string <- strsplit(file_1, "\n")
  text_string_first<-text_string[[1]]
  typ<-text_string_first[3]
  typen<- c(typen, typ)
  
  typ<- text_string[[1]][3]
  
  text_string <- pdf_text("./18_btd/1800038.pdf") %>% 
    strsplit("\n") 
   typ<- text_string[[1]][3]
  text_string_first<-text_string[[1]][3:4]

file_test <- map()

full_file <- path_18[1:10] %>% 
  map(~pdf_text(.x))

readr::read_lines(full_file[[1]])
full_file[1] %>% 
  unlist() %>% 
  str_split("\n") %>% 
  unlist()

pdf_text(path_18[1])

corpus <- Corpus(VectorSource(full_file))
readr::read_lines(corpus$content[1])

class(file_2)


file_2 <- pdf_text("./18_btd/1800038.pdf") %>% 
  unlist()

file_corpus <- Corpus(VectorSource(file))
file_corpus$content

# removing stop words
head(stopwords("de"))
tm_map(corpus, removeWords, stopwords("de"))

file <- str_split(file, "\n")

# cat() makes it more readable
cat(file[1])

testing <- pdf_text("./18_btd/1800038.pdf") %>% 
  strsplit("\n") %>% 
  unlist()

pdf_text_2 <- function(pdf){
  testing <- pdf_text(pdf) %>% 
    strsplit("\n") %>% 
    unlist()
}

pdf_vector_test <- c("./18_btd/1800038.pdf", "./18_btd/1800039.pdf", "./18_btd/1800040.pdf")
map_test <- map(pdf_vector_test,
                ~pdf_text_2(.x))

```


## corpus dtype
This procedure is not used for data manipulation! However, the code exists for documentation.
```{r}

# using tm package for reading pdf-documents
read <- readPDF(engine = "xpdf", 
                control = list(text = "-layout"))

document <- Corpus(URISource("./18_btd/1800038.pdf"), 
                   readerControl = list(reader = read))

# creating test_vector for pdf reading
pdf_vector_test <- c("./18_btd/1800038.pdf", "./18_btd/1800039.pdf", "./18_btd/1800040.pdf")

document2 <- Corpus(URISource(pdf_vector_test, encoding = "UTF-8"), 
                   readerControl = list(reader = read))

content(document2[[3]])

meta(document2[[3]])

doc_2 <- content(document2[[1]])
head(doc_2, 15)

doc_2 %>% 
  str_replace_all("\xdc", "ü") %>% 
  str_replace_all("\xfc", "ü") %>% 
  str_replace_all("\xf6", "ö") 
```

## Merging - Title (18. Bundestag)
```{r}
# reading downloaded csv
DIP21_18 <- read.csv("DIP21Export_18_btd.csv", sep = ";")

# filtering for kleine Anfrage
DIP21_18 %>% 
  filter(DRS_TYP == "Kleine Anfrage")

# creating a new variable with the clean document number
DIP21_18$DRS_NR_clean <- str_replace_all(DIP21_18$DRS_NR, "18/", "")

# creating the document number for matching (same systematic as in the main df)
DIP21_18$DRS_NR_MATCH <- str_pad(DIP21_18$DRS_NR_clean, 5, 'left', pad = '0') %>% 
  paste0("18", .)

# selecting the needed variables and saving the new df at the same time
DIP21_18 %<>% 
  select(DRS_NR, DRS_NR_MATCH, TITLE, DRS_TYP, DATE)

# checking the number for matching
head(DIP21_18)
tail(DIP21_18)
```


## shape files

working with shape files for plotting some maps! :D
```{r}

DIP21_19 <- read.csv("/Users/marlonschumacher/Downloads/DIP21Export.csv", sep = ";")

DIP21_19 %>% 
  filter(DRS_TYP == "Kleine Anfrage")

DIP21_19$DRS_NR_clean <- str_replace_all(DIP21_19$DRS_NR, "19/", "")

DIP21_19$DRS_NR_MATCH <- str_pad(DIP21_19$DRS_NR_clean, 5, 'left', pad = '0') %>% 
  paste0("19", .)

DIP21_19 %<>% 
  select(DRS_NR, DRS_NR_MATCH, DRS_TITLE, DRS_TYP, DATE)



```

